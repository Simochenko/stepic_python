'''Тема урока: сортировка списков
Задача сортировки;
Сортировка пузырьком;
Сортировка выбором;
Сортировка простыми вставками.
Аннотация.  Задачи и способы (алгоритмы) сортировки списков.

Задача сортировки
Задача сортировки списка заключается в перестановке его элементов так, чтобы они были упорядочены по возрастанию или
 убыванию. Это одна из основных задач программирования. Мы сталкиваемся с нею очень часто: при записи фамилий учеников
  в классном журнале, при подведении итогов соревнований и т.д.

Алгоритмы сортировки
Алгоритм сортировки — это алгоритм упорядочивания элементов в списке. Алгоритмы сортировки оцениваются по скорости
 выполнения и эффективности использования памяти:

время — основной параметр, характеризующий быстродействие алгоритма;
память — ряд алгоритмов требует выделения дополнительной памяти под временное хранение данных.
    Алгоритмы сортировки, не потребляющие дополнительной памяти, относят к сортировкам на месте.

Основные алгоритмы сортировки
Медленные:

Пузырьковая сортировка (Bubble sort);
Сортировка выбором (Selection sort);
Сортировка простыми вставками (Insertion sort).
Быстрые:

Сортировка Шелла (Shell sort);
Быстрая сортировка (Quick sort);
Сортировка слиянием (Merge sort);
Пирамидальная сортировка (Heap sort);
Сортировка TimSort (используется в Java и Python).
Большинство алгоритмов сортировки, в частности, указанные выше, основаны на сравнении двух элементов списка.
Существуют однако алгоритмы не основанные на сравнениях. Такие алгоритмы как правило используют наперед заданные
 условия относительно элементов списка. Например, элементами списка являются натуральные или целые числа в некотором
  диапазоне, элементами являются строки и т.д.

К алгоритмам не основанным на сравнениях можно отнести следующие:

Сортировка подсчетом (Counting sort);
Блочная сортировка (Bucket sort);
Поразрядная сортировка (Radix sort).
В рамках курса мы рассмотрим несложные алгоритмы пузырьковой сортировки, сортировки выбором и сортировки простыми
 вставками.

Примечания
Примечание 1. Подробнее об алгоритмах сортировки можно почитать тут.

Примечание 2. Мы называем некоторые алгоритмы сортировки медленными, поскольку они тратят много времени на сортировку
больших списков. Например, если список содержит порядка миллиона элементов, то такие алгоритмы тратят часы, а то и
 дни на выполнение сортировки, в то время как быстрые алгоритмы справляются с задачей за секунды.

Примечание 3. Наглядную работу алгоритмов сортировки на разных входных данных можно посмотреть тут.'''

'''Сортировка пузырьком
Алгоритм сортировки пузырьком состоит из повторяющихся проходов по сортируемому списку. За каждый проход элементы 
последовательно сравниваются попарно и, если порядок в паре неверный, выполняется обмен элементов. Проходы по списку
 повторяются n-1n−1 раз, где nn – длина списка. При каждом проходе алгоритма по внутреннему циклу, очередной 
 наибольший элемент списка ставится на свое место в конце списка рядом с предыдущим «наибольшим элементом».

Наибольший элемент каждый раз «всплывает» до нужной позиции, как пузырёк в воде — отсюда и название алгоритма.

Алгоритм пузырьковой сортировки считается учебным и практически не применяется вне учебной литературы, а на практике 
применяются более эффективные.

Рассмотрим работу алгоритма на примере сортировки списка a = [5, 1, 4, 2, 8] по возрастанию.

Первый проход:

[5, 1, 4, 2, 8] → [1, 5, 4, 2, 8]: меняем местами первый и второй элементы, так как 5 > 15>1;
[1, 5, 4, 2, 8] → [1, 4, 5, 2, 8]: меняем местами второй и третий элементы, так как 5 > 45>4;
[1, 4, 5, 2, 8] → [1, 4, 2, 5, 8]: меняем местами третий и четвертый элементы, так как 5 > 25>2;
[1, 4, 2, 5, 8] → [1, 4, 2, 5, 8]: не меняем четвертый и пятый элементы местами, так как 5 < 85<8;
Самый большой элемент встал («всплыл») на свое место.
Второй проход:

[1, 4, 2, 5, 8] → [1, 4, 2, 5, 8]: не меняем первый и второй элементы местами, так как 1 < 41<4;
[1, 4, 2, 5, 8] → [1, 2, 4, 5, 8]: меняем местами второй и третий элементы, так как 4 > 24>2;
[1, 2, 4, 5, 8] → [1, 2, 4, 5, 8]: не меняем местами третий и четвертый элементы, так как 4 < 54 <5;
Второй по величине элемент встал («всплыл») на свое место.
Теперь список полностью отсортирован, но алгоритму это неизвестно и он работает дальше.

Третий проход:

[1, 2, 4, 5, 8] → [1, 2, 4, 5, 8]: не меняем первый и второй элементы местами, так как 1 < 21<2;
[1, 2, 4, 5, 8] → [1, 2, 4, 5, 8]: не меняем второй и третий элементы местами, так как 2 < 42 <4;
Третий по величине элемент встал («всплыл») на свое место. (на котором и был)
Четвертый проход:

[1, 2, 4, 5, 8] → [1, 2, 4, 5, 8]:
Четвертый по величине элемент встал («всплыл») на свое место.
Теперь список отсортирован и алгоритм может быть завершен.

Визуализация алгоритма


Реализация алгоритма
Пусть требуется отсортировать по возрастанию список чисел: a = [1, 7, -3, 9, 0, -67, 34, 12, 45, 1000, 6,  8, -2, 99].

Следующий программный код реализует алгоритм пузырьковой сортировки:

a = [1, 7, -3, 9, 0, -67, 34, 12, 45, 1000, 6,  8, -2, 99]
n = len(a)

for i in range(n - 1):
    for j in range(n - i - 1):
        if a[j] > a[j + 1]:                  # если порядок элементов пары неправильный
            a[j], a[j + 1] = a[j + 1], a[j]  # меняем элементы пары местами 

print('Отсортированный список:', a)
Результатом выполнения такого кода будет:

Отсортированный список: [-67, -3, -2, 0, 1, 6, 7, 8, 9, 12, 34, 45, 99, 1000]
Оптимизация алгоритма
Алгоритм пузырьковой сортировки можно немного ускорить. Если на одном из очередных проходов окажется, что обмены 
больше не нужны, то это означает, что все элементы списка находятся на своих местах, то есть список отсортирован. 
Для реализации такого ускорения нужно воспользоваться сигнальной меткой, то есть флажком и оператором прерывания
 break.'''
# a = [1, 7, -3, 9, 0, -67, 34, 12, 45, 1000, 6,  8, -2, 99]
# n = len(a)
#
# for i in range(n - 1):
#     for j in range(n - i - 1):
#         if a[j] > a[j + 1]:                  # если порядок элементов пары неправильный
#             a[j], a[j + 1] = a[j + 1], a[j]  # меняем элементы пары местами
#
# print('Отсортированный список:', a)
'''Результатом выполнения такого кода будет:

Отсортированный список: [-67, -3, -2, 0, 1, 6, 7, 8, 9, 12, 34, 45, 99, 1000]'''
# a = [17, 24, 91, 96, 67, -27, 79, -71, -71, 58, 48, 88, 88, -16, -78, 96, -76, 56, 92, 1, 32, -17, 36, 88, -61, -97,
#      -37, -84, 50, 47, 94, -6, 52, -76, 93, 14, -32, 98, -65, -16, -9, -68, -20, -40, -71, 93, -91, 44, 25, 79, 97, 0,
#      -94, 7, -47, -96, -55, -58, -78, -78, -79, 75, 44, -56, -41, 38, 16, 70, 17, -17, -24, -83, -74, -73, 11, -26, 63,
#      -75, -19, -13, -51, -74, 21, -8, 21, -68, -66, -84, -95, 78, 69, -29, 39, 38, -55, 7, -11, -26, -62, -84]
#
# i = 0
# n = len(a)
# for i in range(n - 1):
#     flag = True
#     for j in range(n - i - 1):
#         if a[j] > a[j + 1]:
#             a[j], a[j + 1] = a[j + 1], a[j]
#             flag = False
#     if flag:
#         break
#
# print(a)
'''Сортировка выбором
Сортировка выбором улучшает пузырьковую сортировку, совершая всего один обмен за каждый проход по списку. Для этого 
алгоритм ищет максимальный элемент и помещает его на соответствующую позицию. Как и для пузырьковой сортировки, 
после первого прохода самый большой элемент находится на правильном месте. После второго прохода на своё место 
становится следующий максимальный элемент. Проходы по списку повторяются n-1n−1 раз, где nn – длина списка, 
поскольку последний из них автоматически оказывается на своем месте.

Алгоритм сортировки выбором также считается учебным и практически не применяется вне учебной литературы. На 
практике используют более эффективные алгоритмы.

Рассмотрим работу алгоритма на примере сортировки списка a = [5, 1, 8, 2, 4] по возрастанию.

Первый проход:

Находим максимальный элемент 8 в неотсортированной части списка и меняем его с последним элементом списка:

[5, 1, 4, 2, 8].

Второй проход:

Находим максимальный элемент 5 в неотсортированной части списка и меняем его с предпоследним элементом списка:

[2, 1, 4, 5, 8].

Третий проход:

Находим максимальный элемент 4 в неотсортированной части списка и меняем его с пред-предпоследним элементом списка:

[2, 1, 4, 5, 8].

Четвертый проход:

Находим максимальный элемент 2 в неотсортированной части списка и меняем его с вторым элементом списка:

[1, 2, 4, 5, 8].

Теперь список отсортирован и алгоритм может быть завершен.

    Вместо максимального элемента можно искать минимальный.

Визуализация алгоритма
Выберите в выпадающем списке алгоритм: Selection sort.'''
#
# a = [78, -32, 5, 39, 58, -5, -63, 57, 72, 9, 53, -1, 63, -97, -21, -94, -47, 57, -8, 60, -23, -72, -22, -79, 90, 96,
#      -41, -71, -48, 84, 89, -96, 41, -16, 94, -60, -64, -39, 60, -14, -62, -19, -3, 32, 98, 14, 43, 3, -56, 71, -71,
#      -67, 80, 27, 92, 92, -64, 0, -77, 2, -26, 41, 3, -31, 48, 39, 20, -30, 35, 32, -58, 2, 63, 64, 66, 62, 82, -62, 9,
#      -52, 35, -61, 87, 78, 93, -42, 87, -72, -10, -36, 61, -16, 59, 59, 22, -24, -67, 76, -94, 59]
#
# n = len(a)
# a.sort()
# # реализация алгоритма сортировки выбором
#
# print(a)
# a = [78, -32, 5, 39, 58, -5, -63, 57, 72, 9, 53, -1, 63, -97, -21, -94, -47, 57, -8, 60, -23, -72, -22, -79, 90, 96,
#      -41, -71, -48, 84, 89, -96, 41, -16, 94, -60, -64, -39, 60, -14, -62, -19, -3, 32, 98, 14, 43, 3, -56, 71, -71,
#      -67, 80, 27, 92, 92, -64, 0, -77, 2, -26, 41, 3, -31, 48, 39, 20, -30, 35, 32, -58, 2, 63, 64, 66, 62, 82, -62, 9,
#      -52, 35, -61, 87, 78, 93, -42, 87, -72, -10, -36, 61, -16, 59, 59, 22, -24, -67, 76, -94, 59]
#
# n = len(a)
# b = []
# while len(a) > 0:
#     b.append(min(a))
#     a.remove(min(a))
# a = b
# print(a)

'''Сортировка простыми вставками
Алгоритм сортировки простыми вставками делит список на 2 части — отсортированную и неотсортированную. Из 
неотсортированной части извлекается очередной элемент и вставляется на нужную позицию, в результате чего 
отсортированная часть списка увеличивается, а неотсортированная уменьшается. Так происходит, пока не исчерпан 
набор входных данных  и не отсортированы все элементы.

Сортировка простыми вставками наиболее эффективна когда список уже частично отсортирован и элементов массива 
немного. Если элементов в списке меньше 10, то этот алгоритм — один из самых быстрых.

Рассмотрим его работу на примере сортировки списка a = [5, 1, 8, 2, 4] по возрастанию.

Первый проход:

Делим список на две части: отсортированную [5] и неотсортированную [1, 8, 2, 4].

Извлекаем первый элемент 1 из неотсортированной части списка и находим ему место в отсортированной части:

[1, 5, 4, 2, 8].

Второй проход:

Делим список на две части: отсортированную [1, 5] и неотсортированную [8, 2, 4].

Извлекаем первый элемент 8 из неотсортированной части списка и находим ему место в отсортированной части:

[1, 5, 8, 2, 4].

Третий проход:

Делим список на две части: отсортированную [1, 5, 8] и неотсортированную [2, 4].

Извлекаем первый элемент 2 из неотсортированной части списка и находим ему место в отсортированной части:

[1, 2, 5, 8, 4].

Четвертый проход:

Делим список на две части: отсортированную [1, 2, 5, 8] и неотсортированную [4].

Извлекаем первый элемент 4 из неотсортированной части списка и находим ему место в отсортированной части:

[1, 2, 4, 5, 8].

Теперь список отсортирован и алгоритм может быть завершен.

 Визуализация алгоритма
Выберите в выпадающем списке алгоритм: Insert sort.



Реализация алгоритма
Пусть требуется отсортировать по возрастанию список чисел: a = [1, 7, -3, 9, 0, -67, 34, 12, 45, 1000, 6,  8, -2, 99].

Следующий программный код реализует алгоритм сортировки простыми вставками:

a = [1, 7, -3, 9, 0, -67, 34, 12, 45, 1000, 6,  8, -2, 99]
n = len(a)

for i in range(1, n): 
    elem = a[i]  # первый элемент из неотсортированной части списка
    j = i
    while j >= 1 and a[j - 1] > elem: 
        a[j] = a[j - 1]
        j -= 1
    a[j] = elem


print('Отсортированный список:', a)
Результатом выполнения такого кода будет:

Отсортированный список: [-67, -3, -2, 0, 1, 6, 7, 8, 9, 12, 34, 45, 99, 1000]
Оптимизация алгоритма
Алгоритм сортировки простыми вставками можно значительно ускорить если осуществлять поиск нужной позиции для вставки
 очередного элемента из неотсортированной части списка с помощью бинарного поиска.'''

# numbers = [1, 2, 3, 4, 5]
# # numbers[2] = 99
# # print(numbers)
'''[1, 2, 99, 4, 5]'''
# numbers = list(range(3))
# print(numbers)
# numbers = [10] * 5
# print(numbers)
# numbers = list(range(1, 10, 2))
# for i in numbers:
#     print(i, end='*')
# numbers = [1, 2, 3, 4, 5]
# print(numbers[-2])

# numbers1 = [1, 2, 3]
# numbers2 = [10, 20, 30]
# numbers3 = numbers1 + numbers2
# print(numbers3)

# numbers = [1, 2, 3, 4, 5]
# my_list = numbers[1:3]
# print(my_list)

# numbers = [1, 2, 3, 4, 5]
# my_list = numbers[1:]
# print(my_list)
#
# numbers = [1, 2, 3, 4, 5]
# my_list = numbers[:-1]
# print(my_list)

# numbers = [1, 2, 3, 4, 5]
# my_list = numbers[:]
# print(my_list)

# names = ['Джим', 'Джилл', 'Джон', 'Джасмин']
# if 'Джасмин' not in names:
#     print ('Не могу найти Джасмин.')
# else:
#     print('Ceмья Джасмин: ', end='')
#     print(names)

# a = int(input())
# numbers = list(range(2, a+1, 2))
# print(numbers)

'''Сумма двух списков
На вход программе подаются две строки текста, содержащие целые числа. Из данных строк формируются списки чисел L и M. 
Напишите программу, которая создает третий список, элементами которого являются суммы соответствующих элементов
 списков L и M. Далее программа должна вывести каждый элемент полученного списка на одной строке через 1 символ пробел.

Формат входных данных
На вход программе подаются две строки текста, содержащие целые числа, разделенные символом пробела.

Формат выходных данных
Программа должна вывести текст в соответствии с условием задачи.

Примечание. Количество чисел в обеих строках одинаковое.'''
# print(*map(sum, zip(map(int, input().split()), map(int, input().split()))))

'''Сумма чисел
На вход программе подается строка текста, содержащая натуральные числа. Напишите программу, которая вставляет между
 каждым числом знак +, а затем вычисляет сумму полученных чисел.

Формат входных данных
На вход программе подается строка текста, содержащая натуральные числа, разделенные символом пробела.

Формат выходных данных
Программа должна текст в соответствии с условием задачи.

Примечание. Строковый метод join() работает только со списком строк.'''

# a = input()
# my_list = [int(x) for x in a.split()]
#
# print(f'{"+".join(str(x) for x in my_list)}={sum(my_list)}')
# s = input()
# # l = s.split()
# # m = max(l, key=len)
# # print(len(m))

'''Молодежный жаргон
На вход программе подается строка текста. Напишите программу, использующую списочное выражение, которая 
преобразует каждое слово введенного текста в "молодежный жаргон" по следующему правилу: 

первая буква каждого слова удаляется и ставится в конец слова; 
затем в конец слова добавляется слог "ки".
Формат входных данных
На вход программе подается строка текста на русском языке.

Формат выходных данных
Программа должна вывести текст в соответствии с условием задачи.'''
# a=input()
# new_text = ' '.join(word[1:] + word[0] + 'ки' for word in a.split())
# print(new_text)
'''Валидный номер 🌶️🌶️
На вход программе подается строка текста. Напишите программу, которая определяет является ли введенная 
строка корректным телефонным номером. Строка текста является корректным телефонным номером если она имеет формат:

abc-def-hijk или
7-abc-def-hijk
где a, b, c, d, e, f, h, i, j, k – цифры от 0 до 9.

Формат входных данных 
На вход программе подается строка текста.

Формат выходных данных
Программа должна вывести «YES» если строка является корректным телефонным номером и «NO» в противном случае.

Примечание. Телефонный номер должен содержать только цифры и символ -, а количество цифр в каждой группе должны быть 
правильным.

Sample Input 1:

7-301-447-5820
Sample Output 1:

YES
Sample Input 2:

301-447-5820
Sample Output 2:

YES
Sample Input 3:

301-4477-5820
Sample Output 3:

NO'''
# import re
# print(re.match('^(7-)?(\d{3}-\d{3}-\d{4})$', input()) and 'YES' or 'NO')
n = input().split("-")
c = [len(i) for i in n]
if c == [3, 3, 4] and ''.join(n).isdigit():
    print("YES")
elif c == [1, 3, 3, 4] and ''.join(n).isdigit() and n[0] == '7':
    print("YES")
else:
    print("NO")